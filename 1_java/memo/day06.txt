24-07-01 월요일 6일차
---------리마인드---------
변수
연산자
제어문(조건문: 선택제어문(if-부등호, switch-등호), 반복문: (for-반복횟수 유, while) 
배열
메소드
클래스 
---------- ^_^ -----------

------- ^0^/ 파이팅! -------


다형성(Polymorphism)
	1. 오버로딩(Overloading) - 매개 변수 다름으로 구분하며 메소드 여러 개 선언.
		같은 이름의 메소드를 넘쳐서 여러개 불러오는(선언하는) 기법
		매개변수의 개수 혹은 타입이 다르다면 "매개변수로 각각을 구분"할 수 있기 때문에, 같은 이름의 메소드를 여러개 선언할 수 있다. 
		오버로딩 된 메소드를 사용할 시 전달된 값의 타입 혹은 개수로 구분하여 알맞은 "메소드"가 자동으로 호출된다. 

	2. 오버라이딩(Overriding): (상속의 개념)메소드의 내용을 재정의. (이전 것을 버리고, 다음 것을 우선시 한다) - 부모의 내용을 바꿀 수 있음
		부모 필드에 a()라는 메소드가 존재한다면 자식 객체 생성 시 "부모 필드가 먼저 메모리에 올라가게 되므로" 부모의 a()가 메모리에 먼저 존재한다. 
		그 다음 자식 필드를 완성시킬 때, 똑같은 이름의 a()라는 메소드가 존재한다면, 같은 이름으로 2개가 만들어지는 것이 아니라 
		기존에 만들어진 부모 필드의 a() 메소드 대신에 자식에서 작성한 내용이 사용된다. 
		(부모 필드에 있는 a()에 자식에서 작성한 내용이 덮어 띄워진다.)
		그러므로 자식 객체로 a() 메소드를 사용하게 되면 재정의된 기능으로 사용하며 이것을 오버라이딩 이라고 한다(매개변수 같아야함)



클래스 배열(위치를 일률적?으로 모음) "객체들을 담은 주소(=통상적으로 객체라 함)"들을 일렬로 모아놓은 것임
	객체를 여러개 선언해야 하는 경우 "배열 타입"으로 한번에 선언 후 사용
	각 객체는 규칙성이 없기 때문에 규칙성을 부여하기 위해서 사용
	배열의 한 칸 한 칸이 하나의 객체

클래스 배열 선언
	클래스명[] 배열명 = {
		new 생성자(),
		new 생성자(),
		...
	};
	
	클래스명[] 배열명 = new 클래스명[칸수];

클래스 배열 사용
	각 칸이 객체이기 때문에!! "각 방으로 접근 후" .을 찍고 필드로 접근한다.

	배열명[idx].변수
	배열명[idx].메소드();

static 정적 변수
	Java에서 Static 키워드를 사용한다는 것은 메모리에 한번 할당되어 프로그램이 종료될 때 해제되는 것을 의미


	*cf) 전역변수: 각 객체의 필드에 생성되는 변수들(어디서든 호출하면 사용할 수 있다)
	
	먼저 컴파일을 한다(메모리에 올린다) 객체에 만들어지는 변수(전역변수)는 객체가 만들어 지기 전에는 없음
	
	static은 각체에 올라가지 않음(공간이 하나가 만들어지는거임)
	컴파일을 하면서 메모리에 올린다. 프로그램이 실행되면 바로 만들어진다. 

	*static이 붙은 변수, 메소드, 구역 등은 프로그램 실행 시 가장 먼저 메모리에 올라간다.(생성된다)
	*static이 붙은 메소드 내부에서는 객체의 필드에 올라오는 일반 전역변수나 일반 메소드는 사용할 수 없다. (아직 메모리에 올라오지 않았기 때문에)
	-> 따라서 statie이 붙은 전역변수/메소드/자기 자신 안에 선언된 지역변수만 사용할 수 있다. 
	*static이 붙은 전역변수, 메소드는 모든 객체가 공유한다. 
	따라서 static 필드는 클래스 이름으로 직접 접근이 가능하다.

	각 객체가 실제로 "공유해야 하는 값이나 메소드", 또는 "필드를 사용하지 않는 메소드" 같은 경우에는 static을 붙여서 선언한다.
	(공유하지 않아야 하는 값들이나 필드를 사용하는 메소드에서는 무조건 static을 붙이면 안된다.)

	변수명 자체가 Car.wheel 이라 생각해(소속을 밝힘) <- 객체를 직접 만들지 않아도 클래스 이름으로 직접 접근이 가능하다.
	
클래스 사용 방법
	1. 데이터 포장
	2. 기능 관리(메소드들을 하나의 클래스에 보관하기 위한 용도)

상속(inheritance)
	설계에서부터 시작됨.
	클래스와 클래스 사이에서 일어나는 일들
	1. 기존에 선언된 클래스의 필드를 다른 클래스에서도 사용하고자 할 때
	2. 클래스들을 만들다 보니 공통 요소가 보여서 묶은 후 상속시켜 클래스들을 편하게 만들고자 할 때(클래스의 클래스)

상속 방법
	class A {
		A의 필드(변수, 메소드)
	}

	class B extends A {
		B의 필드
	}

	B obj = new B();
	obj 객체는 실제로 A의 필드와 B의 필드 둘 다 가지고 있다.   

	A: 부모 클래스, 상위 클래스, 슈퍼 클래스, 기반 클래스
	B: 자식 클래스, 하위 클래스, 서브 클래스, 파생 클래스

	상속 관계(설계)정의는 미리 되어있고(코드 작성), 실행은 클래스를 이용해서 객체를 만들 때
	<상속이 일어날 때 메모리 구조> 찾아보기


자식 클래스 생성자 호출 시 일어나는 일
	자식 클래스의 객체는 자식 생성자를 호출해서 객체화를 진행한다. 
	자식 생성자를 호출했으므로 자식 클래스 내의 필드들이 똑같이 복사되어 하나 생성된다. 
	만약 자식 클래스의 필드만 메모리에 올라갔다면 그 객체로 절대 부모 클래스 내부에 있는 필드들은 사용할 수 없다. 
	따라서 자식 생성자를 호출하게 되면 상속 받기로 한 "부모의 필드가 먼저 메모리에 할당"되고 그 이후에 자식 필드도 따라 붙는다. 
	결과적으로 그 객체는 부모 필드가 메모리에 같이 올라와 있기 때문에 부모 클래스의 필드에도 접근할 수 있게 된다. 

--------------------java 1 끝--------------------

메모리 영역 공부
클래스는 static 영역에서 생성되고, new 연산을 통해 생성한 객체는 heap 영역에 생성(GC가 관리함)된다. 
- static 영역에 할당된 메모리는 모든 객체가 공유하는 메모리라는 장점이 있지만, GC가 관리하지 않기 때문에 프로그램의 종료 시까지 메모리가 할당된 채로 존재하게 된다. 
static 변수(정적 변수) 특징
- 클래스 변수이다.
- 객체를 생성하지 않고도 static 자원에 접근이 가능하다. (객체가 생성되기 이전에 이미 할당이 되어 있어 객체 생성 없이 바로 접근(사용)이 가능하다.)

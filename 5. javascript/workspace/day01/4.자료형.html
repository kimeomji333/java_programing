<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>자료형</title>
</head>
<body>
    <h2>자료형</h2>
</body>
<script>
    let num1 = 10;
    let num2 = 5.5;
    let num3 = 3e3; //3 * 10의 3제곱

    console.log(num1);
    console.log(num2);
    console.log(num3);

    // 10 + 5.5 = 15.5
    // 서식화된 문자열(형태가 정해진 문자열)를 정의할 때
    let str = `${num1} + ${num2} = ${num1+num2}`;
    console.log(str);
    // console.log(`${num1} + ${num2} = ${num1+num2}`);

    let str1 = "5";
    let str2 = 'Hello';
    let str3 = `안녕
    하세요`;

    // 문자열에 특정 값을 +하면 문자열 연결이 가능하기 때문에 자동 현변환이 일어나지 않는다.
    console.log(num1+str1);

    // 문자열에 특정 값을 *,-,/하면 특정 연산이 없기 때문에 자동 현변환을 한 후 숫자끼리의 연산으로 해결한다.
    console.log(num1*str1);
    
    console.log(str1*str2); //NaN Not a Number(숫자타입)

    // ``로 선언시에 그대로 출력된다.
    console.log(str3);

    //상수 선언
    const PI = 3.14;
    // PI = 3; 실행 불가

    // 자바스크립트의 리터럴 표기법으로 만든 객체
    const mycar = {model:"Ferrari", color:"Red", price:70000};
    console.log(mycar.model);
    mycar.color = "Yellow";
    console.log(mycar.color);
    // const 상수로 선언된 mycar는 바꿀 수 없지만, 주소값이 다른 mycar.model은 바꿀 수 있다.

    let b1 = true;
    b1 = 10 <3;
    console.log(b1);

    let ud;
    console.log(ud);
    console.log(typeof(ud));

    let nu = null;
    console.log(typeof(nu)); //object
    // 설계상 오류, null 은 실제로 원시 값이지만, typeof 연산자로 확인하면 object가 나온다.
    // typeof 연산자: 피연산자의 자료형을 문자열 형태로 반환한다.

    //자바스크립트의 웃긴점 ㅋ0ㅋ
    console.log("0" == 0); //true
    console.log([] == 0); //true
    console.log([] == "0"); //false
    console.log("\t" == 0); //true
</script>
</html>
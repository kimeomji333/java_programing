24-08-30 금요일
스프링의 특징
	POJO 기반의 구성
	의존성 주입(DI)을 통한 객체 간의 관계 구성
	AOP 지원
	편리한 MVC 구조
	WAS에 종속적이지 않은 개발 환경
	
POJO(Plain Old Java Object) 기반의 구성
	오래된 기존 자바 개발 방식으로 스프링에서 사용을 한다. 쉽게 적응할 수 있기 때문에!
	오래된 방식의 간단한 자바 객체
	JAVA 코드에서 일반적으로 객체를 구성하는 방식을 스프링에서도 그대로 사용할 수 있다.
	스프링 프레임워크에 종속되지 않은 객체를 생성할 수 있다.
	(웹에 종속되지 않아서 앱으로도 활용 가능하다는 것)

스프링 빈(Spring Bean)
	스프링 컨테이너에 의해 관리되는 재사용 가능한 소프트웨어 컴포넌트
	스프링 컨테이너가 관리하는 자바 객체

	스프링 빈(스프링에 등록된 객체) --> 빈(만들어져서 사용할 수 있는 객체) ex.mapper, controller
				인스턴스화

의존성(Dependency)
	객체간의 협력성
	객체가 활동하기 위해 다른 객체를 참조하는 것
		ex) 메소드의 파라미터, 전역변수로 다른 타입의 객체가 선언된 경우
	하나의 객체가 다른 객체 없이 제대로된 역할을 할 수 없다는 것을 의미
		ex) A 객체가 B 객체 없이 동작이 불가능한 상황 - 'A가 B에 의존적이다'
	컴파일 타임 의존성(클래스 사이의 의존성, 클래스를 선언하며 의존성이 결정) - 의존성 높음
	런 타임 의존성(객체 사이의 의존성, 코드를 실행해 보았을 때 의존성이 결정) - 낮음
	
	의존성을 낮추는 방법
		1. 생성자 만들어서 넘기는 방법
		2. Setter 이용하는 방법

IOC(Inversion Of Control)
	제어의 역전 - 스프링에게 주도권이 넘어갔다.
	객체의 생성, 설정, 초기화 등을 개발자가 직접 관리하는 것이 아닌 외부에 맡기는 형태
	객체의 생명 주기를 모두 프레임워크에 위임하는 설계 원칙
	개발자는 프레임워크에게 요청을 한 후 생성하고자 하는 것을 받아서 사용

	IOC 원칙을 실현한 디자인 패턴 중 하나가 DI(Dependency Injection) 
	의존성 주입 - 객체를 투입 당한다.
	*의존하고 있는 형태의 설계
	a <-------------- b
	a 객체에서 b 객체를 직접 생성

	*제어의 역전 형태의 설계
	a <-----> ?? <---- b
	a는 b가 필요하다 라는 신호를 보내고, b 객체를 주입하는 것은 외부에서 이루어짐

	주입(Injection)은 말 그대로 외부에서 밀어 넣는것을 의미한다. 
	어떤 객체가 필요로 하는 객체를 외부에서 밀어 넣어주는 것을 의미한다. 주입을 받는 입장에서는
	어떤 객체인지 신경 쓸 필요가 없고 어떤 객체에 의존하든 자신이 하던 역할은 변하지 않게 된다.
	
	의존성 주입 방식을 이용하기 위해서는 ??라는 존재가 필요하게 된다.
	스프링 프레임워크에서는 ApplicationContext 가 ??라는 존재이며
	필요한 객체를 생성하고 주입까지 해주는 역할을 한다. 따라서 개발자들은
	기존의 프로그래밍과 달리 객체와 객체를 분리해서 생성하고, 
	이러한 객체들을 엮는 (Wiring) 작업의 형태로 개발하게 된다. 

의존성 주입 테스트
	호텔, 레스토랑 객체 안에 셰프 객체를 주입하는 예제
	생성자, setter 메소드를 이용한 주입으로 의존성 주입 구현
	어노테이션을 통해 주입 처리

스프링이 동작시 생기는 일
	스프링이 시작되면서 먼저 스프링이 사용하는 메모리 영역을 만든다.
	스프링 내부적으로 필요한 부분들(내장서버, ApplicationContext 등)이 만들어진다.
	스프링은 자신이 생성하고 관리해야 하는 객체들을 알아야 하고
	@Component 어노테이션을 참고하여 인스턴스를 생성한다.
	Hotel 객체는 Chef 객체가 필요하다는 어노테이션 설정이 있으므로
	등록되어 있는 Chef 객체의 레퍼런스를 Hotel 객체에 주입한다.
	

테스트 환경 구축(JUnit)
	자바 프로그래밍 언어용 유닛 테스트 프레임워크
	가장 많이 이용되는 테스트 환경
	테스트 성공시 JUnit GUI 창에 녹색 / 실패시 적색으로 표시
	하나하나의 케이스 별로(단위로 나누어서) 테스트를 하는 단위 테스트 도구

테스트 환경 구축하기
	1. 테스트 클래스 위쪽에 어노테이션 추가
		@SpringBootTest
	2. 내부에 테스트용 메소드 선언
		내용은 우리가 테스트 해볼 로직으로 구현
		위쪽에 @Test
	3. 해당 클래스 JUint Test로 실행

MyBatis 관련 데스트
	스프링 전체 구동이 필요하지 않기 때문에 @MyBatisTest 만 붙인다.
	@AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE) 
	실제 데이터베이스 환경에 맞게 테스트를 하겠다는 뜻
	
스프링 부트의 구동 순서
	프로젝트 구동은 ~~Application.java에서 시작한다.
	클래스 상단에는 @SpringBootApplication 어노테이션이 등록되어 있다.
	해당 프로젝트를 실행하면 application.properties를 참고한 후 
	내부적으로 필요한 서버와 빈 들이 생성된 후 작동한다.
	그 중에서 DispatcherServlet 이라는 서블릿이 있으며 MVC 구조에서 
	가장 핵심적인 역할을 하는 클래스이고, 내부적으로 앱 관련 처리의 준비 작업을 진행한다.
	(ex. 식당의 총지배인 역할) - 요청/처리/응답을 가장 먼저 맞이하는 프론트컨트롤러 역할을 한다.

	DispatcherServlet은 프론트 컨트롤러의 역할이며 이 서블릿이 구동되는 과정에서
	등록된 객체(SpringBean)들은 주입될 객체(Bean)들과 같이 연동하게 된다.

MVC Model 2
		request				response
	a	->	B.java[Controller]	-> c
			   ↓↑
			DAO, DTO
			   ↓↑
			   DB 

	a 화면에서 다음 페이지를 이동하기 전에 필요한 비즈니스 로직을 
	B.java 에 완벽하게 분리하여 관리한다. 요청시 알맞은 컨트롤러로
	request(요청)을 보내주고 그 곳에서 처리 완료된 결과를 들고
	c 화면으로 이동(response, 응답)하여 출력하는 형태이다.

Front-Controller 패턴
	요청을 처리할 컨트롤러
	지금까지 사용한 /user or /board 처럼 먼저 요청을 받아들이는 곳이라고 생각하면 되겠군
	@RequestMapping("/user")

	View -> Front-Controller -> Controller -> View
	모든 요청 하나하나 마다 컨트롤러를 매칭시켜 놓기에는 개수가 너무 많아
	특정 집단(entity)의 요청들은 하나의 컨트롤러로 가도록 설계한다.
	(ex. 앞에 /user 가 붙은 요청들은 모구 UserController로 가!!
	그 요청들이 모이는 컨트롤러가 Front-Controller 이다.
	각 요청들을 구별하여 알맞은 컨트롤러로 보낼 수 있는 로직이 필요하다.
	
스프링 프로젝트의 F-C 패턴
				HandlerMapping
				↑	↓
	Client -> DispatcherServlet  ←	HandlerAdapter ↔ Controller 
	     ↑			↓
	     ㄴ--−−View ← ViewResolver

	1. 사용자의 Request는 Front-Controller인 DispatcherServlet을 통해 처리한다.
	2. HandlerMapping 은 Request의 처리를 담당할 컨트롤러를 찾기 위해 존재한다. @PostMapping 같은..
	3. HandlerMapping 인터페이스를 구현한 여러 객체 중 @RequestMapping 이라는 어노테이션이 적용된 것을 기준으로 판단하여,
	적절한 컨트롤러를 찾았다면 HandlerAdapter를 이용해서 해당 컨트롤러를 작동시킨다.
	4. Controller의 처리가 완료되었다면 어디로/어떻게 갈 것인지 라는 결과(Redirect or forward )가 나오고
	그 결과를 ViewResolver가 받아서 어떻게 View를 처리할 지 해석을 한다.
	5. 해석된 결과를 가지고 실제 응답을 보내야 하는 데이터를 생성해준다.
	6. 만들어진 응답(데이터, 페이지)을 DispatcherServlet을 통해서 응답해준다.

스프링 MVC Controller의 특징
	HttpServletRequest, HttpServletResponse를 거의 사용할 필요 없이 구현
	다양한 타입의 파라미터 처리, 다양한 타입의 리턴 타입 사용 가능
	GET/POST 방식 등 전송 방식에 대한 처리를 어노테이션으로 처리 가능
	ex) GET : /user/join - join페이지로 이동
	    POST : /user/join - 회원가입 처리
	상속/인터페이스 방식 대신 어노테이션으로 간단하게 매핑 처리 가능

AOP
	Aspect Oriented Programing
	관점 지향 프로그래밍
	하나의 기능을 바라보는 관점에 따라서 	
	비즈니스 로직, 로그 기록, 보안, 트랜잭션 관리 등 다양한 관심사를 분리해서 코드의 모듈화를 높이기 위해 사용되는 프로그래밍
	
	좋은 개발 환경에서는 개발자가 비즈니스 로직에만 집중할 수 있게 한다.
	스프링에서는 반복적인 코드를 제거해줌으로써 핵심 비즈니스 로직에만 집중할 수 있는 방법을 제공한다.
	보안, 로그, 예외처리 등과 같이 비즈니스 로직은 아니지만 반드시 처리해야 할 부분들(횡단 관심사 - cross concern)
	을 따로 분리해서 제작하는 것이 가능하고 횡단 관심사를 모듈로 분리하여 프로그래밍 하는 것을 AOP라고 한다.
	1) 핵심 비즈니스 로직에만 집중해서 코드 개발
	2) 각 프로젝트마다 다른 관심사를 적용할 시 코드 수정 최소화
	3) 원하는 관심사의 유지보수가 수월한 코드 구성이 가능






> 용어에 대한 정의 정리하기
OOP 객체를 중심으로 객체와 클래스를 사용해서 프로그래밍하는 방법
객체들을 중심으로 기능들을 설명하는 것


@Component 를 붙여 스프링에게 맡길 객체들을 알려준다.
스프링이 Hotel 객체를 넘겨주는데, Chef 타입의 객체를 매개변수로 넣어서 넘겨준다. 

autocommit 하지 않고 할 때마다 rollback 설정하는 방법으로 
	@Transactional을 사용하면 테스트 메서드가 실행된 후 자동으로 롤백된다.